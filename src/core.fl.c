// Automatically generated file. Do not edit.
static const char* coreSource __attribute__((unused)) =
"class Bool\n"
"  init()\n"
"    error \"Bool class is not directly callable\"\n"
"class BoundMethod\n"
"  init()\n"
"    error \"BoundMethod class is not directly callable\"\n"
"class Function\n"
"  init()\n"
"    error \"Function class is not directly callable\"\n"
"class `None`\n"
"  init()\n"
"    error \"None class is not directly callable\"\n"
"class Number\n"
"  init()\n"
"    error \"Number class is not directly callable\"\n"
"class Random\n"
"  randByte() = this.randBytes(1)[0]\n"
"\n"
"class Sequence\n"
"  init()\n"
"    error \"Sequence class is not directly callable\"\n"
"\n"
"  attribute count\n"
"    var result = 0\n"
"    each i in this do result = result + 1\n"
"    return result\n"
"\n"
"  attribute isEmpty = not this.iterate(None)\n"
"\n"
"  all(function)\n"
"    var result = True\n"
"    each element in this\n"
"      result = function(element)\n"
"      if not result do return False\n"
"    return True\n"
"\n"
"  any(function)\n"
"    var result = False\n"
"    each element in this\n"
"      result = function(element)\n"
"      if result do return True\n"
"    return False\n"
"\n"
"  contains(item)\n"
"    each element in this\n"
"      if element == item do return True\n"
"    return False\n"
"\n"
"  count(function)\n"
"    var result = 0\n"
"    each element in this\n"
"      if function(element) do result = result + 1\n"
"    return result\n"
"\n"
"  forEach(function)\n"
"    each element in this\n"
"      function(element)\n"
"  \n"
"  sumOf(function) = this.reduce(0, { |acc, i| acc + function(i) })\n"
"\n"
"  maxOf(function)\n"
"    var max = None\n"
"    each element in this\n"
"      val value = function(element)\n"
"      if max == None or value > max do max = value\n"
"    return max\n"
"\n"
"  minOf(function)\n"
"    var min = None\n"
"    each element in this\n"
"      val value = function(element)\n"
"      if min == None or value < min do min = value\n"
"    return min\n"
"\n"
"  lazyMap(transformation) = MapSequence(this, transformation)\n"
"\n"
"  lazyFilter(predicate) = FilterSequence(this, predicate)\n"
"\n"
"  skip(count)\n"
"    if (count is not Number) or (not count.isInteger) or count < 0\n"
"      error \"Count must be a positive integer\"\n"
"\n"
"    return SkipSequence(this, count)\n"
"\n"
"  take(count)\n"
"    if (count is not Number) or (not count.isInteger) or count < 0\n"
"      error \"Count must be a positive integer\"\n"
"\n"
"    return TakeSequence(this, count)\n"
"\n"
"  reduce(acc, function)\n"
"    each element in this\n"
"      acc = function(acc, element)\n"
"    return acc\n"
"\n"
"  reduce(function)\n"
"    var iter = this.iterate(None)\n"
"    if not iter do return\n"
"\n"
"    var result = this.iteratorValue(iter)\n"
"    while iter = this.iterate(iter)\n"
"      result = function(result, this.iteratorValue(iter))\n"
"\n"
"    return result\n"
"\n"
"  joinToString() = this.joinToString(\", \")\n"
"\n"
"  joinToString(sep)\n"
"    var result = \"\"\n"
"\n"
"    each item[index] in this\n"
"      if index != 0 do result = result + sep\n"
"      result = result + item.toString()\n"
"\n"
"    return result\n"
"  \n"
"  joinToString(sep, function)\n"
"    var result = \"\"\n"
"\n"
"    each item[index] in this\n"
"      if index != 0 do result = result + sep\n"
"      result = result + function(item).toString()\n"
"    \n"
"    return result\n"
"\n"
"  toList()\n"
"    val result = List()\n"
"    each element in this\n"
"      result.add(element)\n"
"    return result\n"
"\n"
"class MapSequence < Sequence\n"
"  init(+sequence, +function)\n"
"    pass\n"
"\n"
"  iterate(iterator) = this.sequence.iterate(iterator)\n"
"\n"
"  iteratorValue(iterator)\n"
"    return this.function(this.sequence.iteratorValue(iterator))\n"
"\n"
"class SkipSequence < Sequence\n"
"  init(+sequence, +count)\n"
"    pass\n"
"\n"
"  iterate(iterator)\n"
"    if iterator\n"
"      return this.sequence.iterate(iterator)\n"
"    else\n"
"      iterator = this.sequence.iterate(iterator)\n"
"      for var count = this.count; count > 0 and iterator; count = count - 1\n"
"        iterator = this.sequence.iterate(iterator)\n"
"      return iterator\n"
"\n"
"  iteratorValue(iterator) = this.sequence.iteratorValue(iterator)\n"
"\n"
"class TakeSequence < Sequence\n"
"  init(+sequence, +count)\n"
"    pass\n"
"\n"
"  iterate(iterator)\n"
"    if not iterator do this.taken = 1 else do this.taken = this.taken + 1\n"
"    return None if this.taken > this.count else this.sequence.iterate(iterator)\n"
"\n"
"  iteratorValue(iterator) = this.sequence.iteratorValue(iterator)\n"
"\n"
"class FilterSequence < Sequence\n"
"  init(+sequence, +function)\n"
"    pass\n"
"\n"
"  iterate(iterator)\n"
"    while iterator = this.sequence.iterate(iterator)\n"
"      if this.function(this.sequence.iteratorValue(iterator)) do break\n"
"    return iterator\n"
"\n"
"  iteratorValue(iterator)\n"
"    return this.sequence.iteratorValue(iterator)\n"
"\n"
"class String < Sequence\n"
"  attribute bytes = StringByteSequence(this)\n"
"  attribute codePoints = StringCodePointSequence(this)\n"
"\n"
"  +(other) = this.concatenate(other.toString())\n"
"\n"
"  *(count)\n"
"    if (count is not Number) or (not count.isInteger) or count < 0\n"
"      error \"Count must be a positive integer\"\n"
"\n"
"    var result = \"\"\n"
"    each i in 0..<count\n"
"      result = result + this\n"
"    return result\n"
"\n"
"  split(delimiter)\n"
"    if (delimiter is not String) or delimiter.isEmpty\n"
"      error \"Delimiter must be a string of at least one character\"\n"
"\n"
"    val result = List()\n"
"\n"
"    var last = 0\n"
"    var index = 0\n"
"\n"
"    val delimiterSize = delimiter.byteCount\n"
"    val size = this.byteCount\n"
"\n"
"    while last < size and (index = this.indexOf(delimiter, last)) != -1\n"
"      result.add(this[last..<index])\n"
"      last = index + delimiterSize\n"
"\n"
"    if last < size\n"
"      result.add(this[last..-1])\n"
"    else\n"
"      result.add(\"\")\n"
"\n"
"    return result\n"
"\n"
"  replace(from, to)\n"
"    if (from is not String) or from.isEmpty\n"
"      error \"From value must be a non-empty string\"\n"
"    if to is not String\n"
"      error \"To value must be a string\"\n"
"\n"
"    var result = \"\"\n"
"\n"
"    var last = 0\n"
"    var index = 0\n"
"\n"
"    val fromSize = from.byteCount\n"
"    val size = this.byteCount\n"
"\n"
"    while last < size and (index = this.indexOf(from, last)) != -1\n"
"      result = result + this[last..<index] + to\n"
"      last = index + fromSize\n"
"\n"
"    if last < size do result = result + this[last..-1]\n"
"\n"
"    return result\n"
"\n"
"  trim() = this.trim_(\"\\t\\r\\n \", True, True)\n"
"  trim(chars) = this.trim_(chars, True, True)\n"
"  trimEnd() = this.trim_(\"\\t\\r\\n \", False, True)\n"
"  trimEnd(chars) = this.trim_(chars, False, True)\n"
"  trimStart() = this.trim_(\"\\t\\r\\n \", True, False)\n"
"  trimStart(chars) = this.trim_(chars, True, False)\n"
"\n"
"  trim_(chars, trimStart, trimEnd)\n"
"    if chars is not String\n"
"      error \"Character being trimmed must be a string\"\n"
"\n"
"    val codePoints = chars.codePoints.toList()\n"
"\n"
"    var start\n"
"    if trimStart\n"
"      while start = this.iterate(start)\n"
"        if not codePoints.contains(this.codePointAt(start)) do break\n"
"\n"
"      if start == False do return \"\"\n"
"    else do start = 0\n"
"\n"
"    var end\n"
"    if trimEnd\n"
"      end = this.byteCount - 1\n"
"      while end >= start\n"
"        val codePoint = this.codePointAt(end)\n"
"        if codePoint != -1 and not codePoints.contains(codePoint) do break\n"
"        end = end - 1\n"
"\n"
"      if end <= start do return \"\"\n"
"    else do end = -1\n"
"\n"
"    return this[start..end]\n"
"\n"
"class StringByteSequence < Sequence\n"
"  init(+string)\n"
"    pass\n"
"\n"
"  attribute count = this.string.byteCount\n"
"\n"
"  get(index) = this.string.byteAt(index)\n"
"  iterate(iterator) = this.string.iterateByte(iterator)\n"
"  iteratorValue(iterator) = this.string.byteAt(iterator)\n"
"\n"
"class StringCodePointSequence < Sequence\n"
"  init(+string)\n"
"    pass\n"
"\n"
"  attribute count = this.string.count\n"
"\n"
"  get(index) = this.string.codePointAt(index)\n"
"  iterate(iterator) = this.string.iterate(iterator)\n"
"  iteratorValue(iterator) = this.string.codePointAt(iterator)\n"
"\n"
"class List < Sequence\n"
"  +(other)\n"
"    val result = this[0..-1]\n"
"    each element in other\n"
"      result.add(element)\n"
"    return result\n"
"\n"
"  *(count)\n"
"    if (count is not Number) or (not count.isInteger) or count < 0\n"
"      error \"Count must be a positive integer\"\n"
"\n"
"    val result = List()\n"
"    each i in 0..<count\n"
"      result.addAll(this)\n"
"    return result\n"
"\n"
"  addAll(other)\n"
"    each element in other\n"
"      this.add(element)\n"
"\n"
"  map(transformation)\n"
"    val result = List()\n"
"    each item in this\n"
"      result.add(transformation(item))\n"
"    return result\n"
"\n"
"  filter(predicate)\n"
"    val result = List()\n"
"    each item in this\n"
"      if predicate(item) do result.add(item)\n"
"    return result\n"
"\n"
"  sort()\n"
"    this.sort { |low, high| low <= high }\n"
"\n"
"  sort(comparer)\n"
"    if comparer is not Function\n"
"      error \"Comparer must be a function\"\n"
"    this.quicksort(0, this.size - 1, comparer)\n"
"\n"
"  quicksort(low, high, comparer)\n"
"    if low < high\n"
"      val p = this.partition(low, high, comparer)\n"
"      this.quicksort(low, p - 1, comparer)\n"
"      this.quicksort(p + 1, high, comparer)\n"
"  \n"
"  sum() = this.reduce { |acc, item| acc + item }\n"
"\n"
"  partition(low, high, comparer)\n"
"    val pivot = this[high]\n"
"    var i = low - 1\n"
"    each j in low..<high\n"
"      if comparer(this[j], pivot)\n"
"        i = i + 1\n"
"        this.swap(i, j)\n"
"    this.swap(i + 1, high)\n"
"    return i + 1\n"
"\n"
"  toString() = \"[=(this.joinToString())]\"\n"
"\n"
"class Map < Sequence\n"
"  attribute keys = MapKeySequence(this)\n"
"  attribute values = MapValueSequence(this)\n"
"\n"
"  toString()\n"
"    var result = \"[\"\n"
"    var first = True\n"
"\n"
"    each key in this.keys\n"
"      if not first do result = result + \", \"\n"
"      first = False\n"
"      result = result + \"=(key) -> =(this[key])\"\n"
"\n"
"    return result + \"]\"\n"
"\n"
"  iteratorValue(iterator) = MapEntry(this.keyIteratorValue(iterator), this.valueIteratorValue(iterator))\n"
"\n"
"class MapEntry\n"
"  init(+key, +value)\n"
"    pass\n"
"\n"
"  toString() = \"=(this.key)->=(this.value)\"\n"
"\n"
"class MapKeySequence < Sequence\n"
"  init(+map)\n"
"    pass\n"
"\n"
"  iterate(n) = this.map.iterate(n)\n"
"  iteratorValue(iterator) = this.map.keyIteratorValue(iterator)\n"
"\n"
"class MapValueSequence < Sequence\n"
"  init(+map)\n"
"    pass\n"
"\n"
"  iterate(n) = this.map.iterate(n)\n"
"  iteratorValue(iterator) = this.map.valueIteratorValue(iterator)\n"
"\n"
"class Range < Sequence []\n"
"class Tuple < Sequence\n"
"  init()\n"
"    error \"Tuple class is not directly callable\"\n"
"\n"
"  toString()\n"
"    result = \"(\"\n"
"    for var i = 0; i < this.count; i = i + 1\n"
"      result = result + this[i]\n"
"      if i != this.count - 1 do result = result + \", \"\n"
"    result = result + \")\"\n"
"    return result\n"
"\n"
"class Sys\n"
"  init()\n"
"    error \"Sys class is not instantiable\"\n"
"\n"
"  static `print`()\n"
"    Sys.writeString(\"\\n\")\n"
"\n"
"  static `print`(obj)\n"
"    Sys.writeObject(obj)\n"
"    Sys.writeString(\"\\n\")\n"
"    return obj\n"
"\n"
"  static printAll(sequence)\n"
"    each object in sequence do Sys.writeObject(object)\n"
"    Sys.writeString(\"\\n\")\n"
"\n"
"  static write(obj)\n"
"    Sys.writeObject(obj)\n"
"    return obj\n"
"\n"
"  static writeAll(sequence)\n"
"    each object in sequence do Sys.writeObject(object)\n"
"\n"
"  static writeObject(obj)\n"
"    var string = obj.toString()\n"
"    if string is not String\n"
"      string = \"[invalid toString() method]\"\n"
"\n"
"    Sys.writeString(string)\n"
"\n"
"  static input() = Sys.input(\"\")\n";
